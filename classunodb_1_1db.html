<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UnoDB: unodb::db&lt; Key, Value &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UnoDB
   </div>
   <div id="projectbrief">Adaptive Radix Tree in C++, optionally with Optimistic Lock Coupling</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classunodb_1_1db.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classunodb_1_1db-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">unodb::db&lt; Key, Value &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A non-thread-safe implementation of the Adaptive Radix Tree (ART).  
 <a href="classunodb_1_1db.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="art_8hpp_source.html">art.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal iterator for tree traversal.  <a href="classunodb_1_1db_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac3e9da364737e347b1d03b51bbe42fdd" id="r_ac3e9da364737e347b1d03b51bbe42fdd"><td class="memItemLeft" align="right" valign="top"><a id="ac3e9da364737e347b1d03b51bbe42fdd" name="ac3e9da364737e347b1d03b51bbe42fdd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="memdesc:ac3e9da364737e347b1d03b51bbe42fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the keys in the index. <br /></td></tr>
<tr class="separator:ac3e9da364737e347b1d03b51bbe42fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadaa147eb4dc87207e42fb481ce46678" id="r_aadaa147eb4dc87207e42fb481ce46678"><td class="memItemLeft" align="right" valign="top"><a id="aadaa147eb4dc87207e42fb481ce46678" name="aadaa147eb4dc87207e42fb481ce46678"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = Value</td></tr>
<tr class="memdesc:aadaa147eb4dc87207e42fb481ce46678"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the value associated with the keys in the index. <br /></td></tr>
<tr class="separator:aadaa147eb4dc87207e42fb481ce46678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9217d27d320c8d140a52bfd05031248e" id="r_a9217d27d320c8d140a52bfd05031248e"><td class="memItemLeft" align="right" valign="top"><a id="a9217d27d320c8d140a52bfd05031248e" name="a9217d27d320c8d140a52bfd05031248e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_view</b> = <a class="el" href="namespaceunodb.html#ae25127f715f2aac269da8a3616284c0b">unodb::value_view</a></td></tr>
<tr class="memdesc:a9217d27d320c8d140a52bfd05031248e"><td class="mdescLeft">&#160;</td><td class="mdescRight">View type for values stored in the index. <br /></td></tr>
<tr class="separator:a9217d27d320c8d140a52bfd05031248e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8040aaa218a91aa2c6e8cb3f5fc86f09" id="r_a8040aaa218a91aa2c6e8cb3f5fc86f09"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a8040aaa218a91aa2c6e8cb3f5fc86f09">get_result</a> = std::optional&lt; <a class="el" href="classunodb_1_1db.html#a9217d27d320c8d140a52bfd05031248e">value_view</a> &gt;</td></tr>
<tr class="memdesc:a8040aaa218a91aa2c6e8cb3f5fc86f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for get operations.  <br /></td></tr>
<tr class="separator:a8040aaa218a91aa2c6e8cb3f5fc86f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef0b022638c82751c073e9886177e3e" id="r_aaef0b022638c82751c073e9886177e3e"><td class="memItemLeft" align="right" valign="top"><a id="aaef0b022638c82751c073e9886177e3e" name="aaef0b022638c82751c073e9886177e3e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_base</b> = <a class="el" href="namespaceunodb_1_1detail.html#af486b3ba28a2f7e238e2db1946e3b8fb">detail::inode_base</a>&lt; Key, Value &gt;</td></tr>
<tr class="memdesc:aaef0b022638c82751c073e9886177e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class type for internal nodes. <br /></td></tr>
<tr class="separator:aaef0b022638c82751c073e9886177e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add4e72d90b2c76b96e6950f3811280f4" id="r_add4e72d90b2c76b96e6950f3811280f4"><td class="memItemLeft" align="right" valign="top"><a id="add4e72d90b2c76b96e6950f3811280f4" name="add4e72d90b2c76b96e6950f3811280f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>db</b> () noexcept=default</td></tr>
<tr class="memdesc:add4e72d90b2c76b96e6950f3811280f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty ART index. <br /></td></tr>
<tr class="separator:add4e72d90b2c76b96e6950f3811280f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985328c3b15963c73eda8e27731eaeef" id="r_a985328c3b15963c73eda8e27731eaeef"><td class="memItemLeft" align="right" valign="top"><a id="a985328c3b15963c73eda8e27731eaeef" name="a985328c3b15963c73eda8e27731eaeef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~db</b> () noexcept</td></tr>
<tr class="memdesc:a985328c3b15963c73eda8e27731eaeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy ART index, freeing all tree nodes. <br /></td></tr>
<tr class="separator:a985328c3b15963c73eda8e27731eaeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66281ca85f1e7c2c86e1c165031fdf6f" id="r_a66281ca85f1e7c2c86e1c165031fdf6f"><td class="memItemLeft" align="right" valign="top"><a id="a66281ca85f1e7c2c86e1c165031fdf6f" name="a66281ca85f1e7c2c86e1c165031fdf6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>db</b> (const <a class="el" href="classunodb_1_1db.html">db</a> &amp;)=delete</td></tr>
<tr class="memdesc:a66281ca85f1e7c2c86e1c165031fdf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (deleted). <br /></td></tr>
<tr class="separator:a66281ca85f1e7c2c86e1c165031fdf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb54ef811e9d36a1f603153a38987656" id="r_aeb54ef811e9d36a1f603153a38987656"><td class="memItemLeft" align="right" valign="top"><a id="aeb54ef811e9d36a1f603153a38987656" name="aeb54ef811e9d36a1f603153a38987656"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>db</b> (<a class="el" href="classunodb_1_1db.html">db</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:aeb54ef811e9d36a1f603153a38987656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor (deleted). <br /></td></tr>
<tr class="separator:aeb54ef811e9d36a1f603153a38987656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabae2dc7a820ccc8f115d8ba1a475e16" id="r_aabae2dc7a820ccc8f115d8ba1a475e16"><td class="memItemLeft" align="right" valign="top"><a id="aabae2dc7a820ccc8f115d8ba1a475e16" name="aabae2dc7a820ccc8f115d8ba1a475e16"></a>
<a class="el" href="classunodb_1_1db.html">db</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classunodb_1_1db.html">db</a> &amp;)=delete</td></tr>
<tr class="memdesc:aabae2dc7a820ccc8f115d8ba1a475e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator (deleted). <br /></td></tr>
<tr class="separator:aabae2dc7a820ccc8f115d8ba1a475e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ba6bf42779528ba151eeeaf942a800" id="r_a69ba6bf42779528ba151eeeaf942a800"><td class="memItemLeft" align="right" valign="top"><a id="a69ba6bf42779528ba151eeeaf942a800" name="a69ba6bf42779528ba151eeeaf942a800"></a>
<a class="el" href="classunodb_1_1db.html">db</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classunodb_1_1db.html">db</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a69ba6bf42779528ba151eeeaf942a800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator (deleted). <br /></td></tr>
<tr class="separator:a69ba6bf42779528ba151eeeaf942a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e7a9acc9be89745bba099062f7bc4" id="r_a7a9e7a9acc9be89745bba099062f7bc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunodb_1_1db.html#a8040aaa218a91aa2c6e8cb3f5fc86f09">get_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a7a9e7a9acc9be89745bba099062f7bc4">get</a> (Key search_key) const noexcept</td></tr>
<tr class="memdesc:a7a9e7a9acc9be89745bba099062f7bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for a value associated with a key.  <br /></td></tr>
<tr class="separator:a7a9e7a9acc9be89745bba099062f7bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889caf36fba0297367a3061d7b580901" id="r_a889caf36fba0297367a3061d7b580901"><td class="memItemLeft" align="right" valign="top"><a id="a889caf36fba0297367a3061d7b580901" name="a889caf36fba0297367a3061d7b580901"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:a889caf36fba0297367a3061d7b580901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the index is empty. <br /></td></tr>
<tr class="separator:a889caf36fba0297367a3061d7b580901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7358904a10483d1e9857b81e0aa38152" id="r_a7358904a10483d1e9857b81e0aa38152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a7358904a10483d1e9857b81e0aa38152">insert</a> (Key insert_key, <a class="el" href="classunodb_1_1db.html#aadaa147eb4dc87207e42fb481ce46678">value_type</a> v)</td></tr>
<tr class="memdesc:a7358904a10483d1e9857b81e0aa38152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value under a key iff there is no entry for that key.  <br /></td></tr>
<tr class="separator:a7358904a10483d1e9857b81e0aa38152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd57c327e541afc96495bb543390cff" id="r_acdd57c327e541afc96495bb543390cff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#acdd57c327e541afc96495bb543390cff">remove</a> (Key search_key)</td></tr>
<tr class="memdesc:acdd57c327e541afc96495bb543390cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the entry associated with the key.  <br /></td></tr>
<tr class="separator:acdd57c327e541afc96495bb543390cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a35859ae49a6255bfa729ebe12702fd" id="r_a6a35859ae49a6255bfa729ebe12702fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a6a35859ae49a6255bfa729ebe12702fd">clear</a> () noexcept</td></tr>
<tr class="memdesc:a6a35859ae49a6255bfa729ebe12702fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries in the index.  <br /></td></tr>
<tr class="separator:a6a35859ae49a6255bfa729ebe12702fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c3cecb362e9535cc3cc3719621b0ae" id="r_a33c3cecb362e9535cc3cc3719621b0ae"><td class="memItemLeft" align="right" valign="top"><a id="a33c3cecb362e9535cc3cc3719621b0ae" name="a33c3cecb362e9535cc3cc3719621b0ae"></a>
<a class="el" href="classunodb_1_1db_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>test_only_iterator</b> () noexcept</td></tr>
<tr class="separator:a33c3cecb362e9535cc3cc3719621b0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public scan API</div></td></tr>
<tr class="memitem:a27a69c736ca0405bc8eaed20cf875a09" id="r_a27a69c736ca0405bc8eaed20cf875a09"><td class="memTemplParams" colspan="2">template&lt;typename FN &gt; </td></tr>
<tr class="memitem:a27a69c736ca0405bc8eaed20cf875a09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a27a69c736ca0405bc8eaed20cf875a09">scan</a> (FN fn, bool fwd=true)</td></tr>
<tr class="memdesc:a27a69c736ca0405bc8eaed20cf875a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan the tree, applying the caller's lambda to each visited leaf.  <br /></td></tr>
<tr class="separator:a27a69c736ca0405bc8eaed20cf875a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d68530937371b08951f2084761b56fd" id="r_a5d68530937371b08951f2084761b56fd"><td class="memTemplParams" colspan="2">template&lt;typename FN &gt; </td></tr>
<tr class="memitem:a5d68530937371b08951f2084761b56fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a5d68530937371b08951f2084761b56fd">scan_from</a> (Key from_key, FN fn, bool fwd=true)</td></tr>
<tr class="memdesc:a5d68530937371b08951f2084761b56fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan in the indicated direction, applying the caller's lambda to each visited leaf.  <br /></td></tr>
<tr class="separator:a5d68530937371b08951f2084761b56fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f45c60b21a68bfd64062ca2c2be2ddf" id="r_a5f45c60b21a68bfd64062ca2c2be2ddf"><td class="memTemplParams" colspan="2">template&lt;typename FN &gt; </td></tr>
<tr class="memitem:a5f45c60b21a68bfd64062ca2c2be2ddf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a5f45c60b21a68bfd64062ca2c2be2ddf">scan_range</a> (Key from_key, Key to_key, FN fn)</td></tr>
<tr class="memdesc:a5f45c60b21a68bfd64062ca2c2be2ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan a half-open key range, applying the caller's lambda to each visited leaf.  <br /></td></tr>
<tr class="separator:a5f45c60b21a68bfd64062ca2c2be2ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Statistics</div></td></tr>
<tr class="memitem:ac0705aacac581408a26b3b6741687c9d" id="r_ac0705aacac581408a26b3b6741687c9d"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#ac0705aacac581408a26b3b6741687c9d">get_current_memory_use</a> () const noexcept</td></tr>
<tr class="memdesc:ac0705aacac581408a26b3b6741687c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current memory use by tree nodes in bytes.  <br /></td></tr>
<tr class="separator:ac0705aacac581408a26b3b6741687c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad212d72357366800d501bb601f2cadd8" id="r_ad212d72357366800d501bb601f2cadd8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </td></tr>
<tr class="memitem:ad212d72357366800d501bb601f2cadd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#ad212d72357366800d501bb601f2cadd8">get_node_count</a> () const noexcept</td></tr>
<tr class="memdesc:ad212d72357366800d501bb601f2cadd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return count of nodes of given type.  <br /></td></tr>
<tr class="separator:ad212d72357366800d501bb601f2cadd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e8f31d59d74ca76710b56ee5953677" id="r_a58e8f31d59d74ca76710b56ee5953677"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunodb.html#a8105523dd9adff845377f54dd034b838">node_type_counter_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a58e8f31d59d74ca76710b56ee5953677">get_node_counts</a> () const noexcept</td></tr>
<tr class="memdesc:a58e8f31d59d74ca76710b56ee5953677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return counts of all node types.  <br /></td></tr>
<tr class="separator:a58e8f31d59d74ca76710b56ee5953677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33bdb6e96d491512f1656f176f2bb59" id="r_aa33bdb6e96d491512f1656f176f2bb59"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </td></tr>
<tr class="memitem:aa33bdb6e96d491512f1656f176f2bb59"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#aa33bdb6e96d491512f1656f176f2bb59">get_growing_inode_count</a> () const noexcept</td></tr>
<tr class="memdesc:aa33bdb6e96d491512f1656f176f2bb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return count of growing operations for given inode type.  <br /></td></tr>
<tr class="separator:aa33bdb6e96d491512f1656f176f2bb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826e03c799300f945a0e663a801185b1" id="r_a826e03c799300f945a0e663a801185b1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunodb.html#a60a52550ffa9f2d0d9e1cd9ebc7cab28">inode_type_counter_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a826e03c799300f945a0e663a801185b1">get_growing_inode_counts</a> () const noexcept</td></tr>
<tr class="memdesc:a826e03c799300f945a0e663a801185b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return counts of all growing inode operations.  <br /></td></tr>
<tr class="separator:a826e03c799300f945a0e663a801185b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257561ecf32c807080442bfbee2d8429" id="r_a257561ecf32c807080442bfbee2d8429"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </td></tr>
<tr class="memitem:a257561ecf32c807080442bfbee2d8429"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a257561ecf32c807080442bfbee2d8429">get_shrinking_inode_count</a> () const noexcept</td></tr>
<tr class="memdesc:a257561ecf32c807080442bfbee2d8429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return count of shrinking operations for given inode type.  <br /></td></tr>
<tr class="separator:a257561ecf32c807080442bfbee2d8429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83c0f84e7ed86b932aed9322cb47b7f" id="r_af83c0f84e7ed86b932aed9322cb47b7f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunodb.html#a60a52550ffa9f2d0d9e1cd9ebc7cab28">inode_type_counter_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#af83c0f84e7ed86b932aed9322cb47b7f">get_shrinking_inode_counts</a> () const noexcept</td></tr>
<tr class="memdesc:af83c0f84e7ed86b932aed9322cb47b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return counts of all shrinking inode operations.  <br /></td></tr>
<tr class="separator:af83c0f84e7ed86b932aed9322cb47b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bcec7d62e67207135e908b1fd607fc" id="r_a60bcec7d62e67207135e908b1fd607fc"><td class="memItemLeft" align="right" valign="top">constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a60bcec7d62e67207135e908b1fd607fc">get_key_prefix_splits</a> () const noexcept</td></tr>
<tr class="memdesc:a60bcec7d62e67207135e908b1fd607fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return count of key prefix split operations.  <br /></td></tr>
<tr class="separator:a60bcec7d62e67207135e908b1fd607fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging</div></td></tr>
<tr class="memitem:ace60a7cffca8eaed4b623eaaf7ba78b7" id="r_ace60a7cffca8eaed4b623eaaf7ba78b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#ace60a7cffca8eaed4b623eaaf7ba78b7">dump</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:ace60a7cffca8eaed4b623eaaf7ba78b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output tree structure to stream for debugging.  <br /></td></tr>
<tr class="separator:ace60a7cffca8eaed4b623eaaf7ba78b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847a8985a8d87ae07d2a8667a16239d" id="r_a5847a8985a8d87ae07d2a8667a16239d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a5847a8985a8d87ae07d2a8667a16239d">dump</a> () const</td></tr>
<tr class="memdesc:a5847a8985a8d87ae07d2a8667a16239d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output tree structure to stderr for debugging.  <br /></td></tr>
<tr class="separator:a5847a8985a8d87ae07d2a8667a16239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad9ca6b1eea4f0b912097978dd1eba982" id="r_ad9ca6b1eea4f0b912097978dd1eba982"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#ad9ca6b1eea4f0b912097978dd1eba982">key_found</a> (const <a class="el" href="classunodb_1_1db.html#a8040aaa218a91aa2c6e8cb3f5fc86f09">get_result</a> &amp;result) noexcept</td></tr>
<tr class="memdesc:ad9ca6b1eea4f0b912097978dd1eba982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if get operation found a key.  <br /></td></tr>
<tr class="separator:ad9ca6b1eea4f0b912097978dd1eba982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa6414555472551bb85db668441cccfae" id="r_aa6414555472551bb85db668441cccfae"><td class="memItemLeft" align="right" valign="top"><a id="aa6414555472551bb85db668441cccfae" name="aa6414555472551bb85db668441cccfae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>art_key_type</b> = <a class="el" href="structunodb_1_1detail_1_1basic__art__key.html">detail::basic_art_key</a>&lt; Key &gt;</td></tr>
<tr class="memdesc:aa6414555472551bb85db668441cccfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal encoded key type used for tree operations. <br /></td></tr>
<tr class="separator:aa6414555472551bb85db668441cccfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4e89eed58d0d9c5e0b3834d5c435a5" id="r_a9c4e89eed58d0d9c5e0b3834d5c435a5"><td class="memItemLeft" align="right" valign="top"><a id="a9c4e89eed58d0d9c5e0b3834d5c435a5" name="a9c4e89eed58d0d9c5e0b3834d5c435a5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>leaf_type</b> = <a class="el" href="namespaceunodb_1_1detail.html#aab561be018ef4d04aa8a144bb388b721">detail::leaf_type</a>&lt; Key &gt;</td></tr>
<tr class="memdesc:a9c4e89eed58d0d9c5e0b3834d5c435a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaf node type storing key-value pairs. <br /></td></tr>
<tr class="separator:a9c4e89eed58d0d9c5e0b3834d5c435a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef30a0e40bd63ec85e061eb618f63d3e" id="r_aef30a0e40bd63ec85e061eb618f63d3e"><td class="memItemLeft" align="right" valign="top"><a id="aef30a0e40bd63ec85e061eb618f63d3e" name="aef30a0e40bd63ec85e061eb618f63d3e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>db_type</b> = <a class="el" href="classunodb_1_1db.html">db</a>&lt; Key, Value &gt;</td></tr>
<tr class="memdesc:aef30a0e40bd63ec85e061eb618f63d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Database type (self-reference for template instantiation). <br /></td></tr>
<tr class="separator:aef30a0e40bd63ec85e061eb618f63d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178657a717c0771b7038d18ce86d64a" id="r_a2178657a717c0771b7038d18ce86d64a"><td class="memItemLeft" align="right" valign="top"><a id="a2178657a717c0771b7038d18ce86d64a" name="a2178657a717c0771b7038d18ce86d64a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>art_policy</b> = <a class="el" href="namespaceunodb_1_1detail.html#aedf36d7f939b56845e7334c790d07195">detail::art_policy</a>&lt; Key, Value &gt;</td></tr>
<tr class="memdesc:a2178657a717c0771b7038d18ce86d64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy type for ART implementation. <br /></td></tr>
<tr class="separator:a2178657a717c0771b7038d18ce86d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b3a6b42fecf6463a4a093e54c2da13" id="r_a58b3a6b42fecf6463a4a093e54c2da13"><td class="memItemLeft" align="right" valign="top"><a id="a58b3a6b42fecf6463a4a093e54c2da13" name="a58b3a6b42fecf6463a4a093e54c2da13"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>header_type</b> = typename <a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html#a617c611c68387ce3a3e195948c028833">art_policy::header_type</a></td></tr>
<tr class="memdesc:a58b3a6b42fecf6463a4a093e54c2da13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node header type. <br /></td></tr>
<tr class="separator:a58b3a6b42fecf6463a4a093e54c2da13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bb3c0e13c4e2924b30de9e6cfdd822" id="r_aa8bb3c0e13c4e2924b30de9e6cfdd822"><td class="memItemLeft" align="right" valign="top"><a id="aa8bb3c0e13c4e2924b30de9e6cfdd822" name="aa8bb3c0e13c4e2924b30de9e6cfdd822"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_type</b> = <a class="el" href="classunodb_1_1detail_1_1inode.html">detail::inode</a>&lt; Key, Value &gt;</td></tr>
<tr class="memdesc:aa8bb3c0e13c4e2924b30de9e6cfdd822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node base type. <br /></td></tr>
<tr class="separator:aa8bb3c0e13c4e2924b30de9e6cfdd822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497f73c9309151323bc4e650496bcb1f" id="r_a497f73c9309151323bc4e650496bcb1f"><td class="memItemLeft" align="right" valign="top"><a id="a497f73c9309151323bc4e650496bcb1f" name="a497f73c9309151323bc4e650496bcb1f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_4</b> = <a class="el" href="classunodb_1_1detail_1_1inode__4.html">detail::inode_4</a>&lt; Key, Value &gt;</td></tr>
<tr class="memdesc:a497f73c9309151323bc4e650496bcb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type with 4 children. <br /></td></tr>
<tr class="separator:a497f73c9309151323bc4e650496bcb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792923c1d17a8abac900b216a35d074e" id="r_a792923c1d17a8abac900b216a35d074e"><td class="memItemLeft" align="right" valign="top"><a id="a792923c1d17a8abac900b216a35d074e" name="a792923c1d17a8abac900b216a35d074e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tree_depth_type</b> = <a class="el" href="classunodb_1_1detail_1_1tree__depth.html">detail::tree_depth</a>&lt; <a class="el" href="classunodb_1_1db.html#aa6414555472551bb85db668441cccfae">art_key_type</a> &gt;</td></tr>
<tr class="memdesc:a792923c1d17a8abac900b216a35d074e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tree depth tracking type. <br /></td></tr>
<tr class="separator:a792923c1d17a8abac900b216a35d074e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf632bcc3c700db5c6b77fbd2884e63" id="r_a6bf632bcc3c700db5c6b77fbd2884e63"><td class="memItemLeft" align="right" valign="top"><a id="a6bf632bcc3c700db5c6b77fbd2884e63" name="a6bf632bcc3c700db5c6b77fbd2884e63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>visitor_type</b> = <a class="el" href="classunodb_1_1visitor.html">visitor</a>&lt; <a class="el" href="classunodb_1_1db_1_1iterator.html">db_type::iterator</a> &gt;</td></tr>
<tr class="memdesc:a6bf632bcc3c700db5c6b77fbd2884e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor type for scan operations. <br /></td></tr>
<tr class="separator:a6bf632bcc3c700db5c6b77fbd2884e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e571b1577b3d502f97857fa4f4bd839" id="r_a9e571b1577b3d502f97857fa4f4bd839"><td class="memItemLeft" align="right" valign="top"><a id="a9e571b1577b3d502f97857fa4f4bd839" name="a9e571b1577b3d502f97857fa4f4bd839"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inode_defs_type</b> = <a class="el" href="namespaceunodb_1_1detail.html#a6e0155f4cc9c31cf3cc24939b69c13d0">detail::inode_defs</a>&lt; Key, Value &gt;</td></tr>
<tr class="memdesc:a9e571b1577b3d502f97857fa4f4bd839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node definitions bundle. <br /></td></tr>
<tr class="separator:a9e571b1577b3d502f97857fa4f4bd839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8c85162848d3a9d514b985539d325d39" id="r_a8c85162848d3a9d514b985539d325d39"><td class="memItemLeft" align="right" valign="top"><a id="a8c85162848d3a9d514b985539d325d39" name="a8c85162848d3a9d514b985539d325d39"></a>
<a class="el" href="classunodb_1_1db.html#a8040aaa218a91aa2c6e8cb3f5fc86f09">get_result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_internal</b> (<a class="el" href="classunodb_1_1db.html#aa6414555472551bb85db668441cccfae">art_key_type</a> search_key) const noexcept</td></tr>
<tr class="memdesc:a8c85162848d3a9d514b985539d325d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query for a value associated with an encoded <em>search_key</em>. <br /></td></tr>
<tr class="separator:a8c85162848d3a9d514b985539d325d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1862efafda8cc7a6e422796af77b416" id="r_af1862efafda8cc7a6e422796af77b416"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#af1862efafda8cc7a6e422796af77b416">insert_internal</a> (<a class="el" href="classunodb_1_1db.html#aa6414555472551bb85db668441cccfae">art_key_type</a> insert_key, <a class="el" href="classunodb_1_1db.html#aadaa147eb4dc87207e42fb481ce46678">value_type</a> v)</td></tr>
<tr class="memdesc:af1862efafda8cc7a6e422796af77b416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value under an encoded key iff there is no entry for that key.  <br /></td></tr>
<tr class="separator:af1862efafda8cc7a6e422796af77b416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad83dc7ab1473008d02fea28905ae87" id="r_a2ad83dc7ab1473008d02fea28905ae87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a2ad83dc7ab1473008d02fea28905ae87">remove_internal</a> (<a class="el" href="classunodb_1_1db.html#aa6414555472551bb85db668441cccfae">art_key_type</a> remove_key)</td></tr>
<tr class="memdesc:a2ad83dc7ab1473008d02fea28905ae87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the entry associated with the encoded key <em>remove_key</em>.  <br /></td></tr>
<tr class="separator:a2ad83dc7ab1473008d02fea28905ae87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0f5954facad165ab605bde004ca19" id="r_ab5a0f5954facad165ab605bde004ca19"><td class="memItemLeft" align="right" valign="top"><a id="ab5a0f5954facad165ab605bde004ca19" name="ab5a0f5954facad165ab605bde004ca19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_root_subtree</b> () noexcept</td></tr>
<tr class="memdesc:ab5a0f5954facad165ab605bde004ca19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete entire tree starting from root. <br /></td></tr>
<tr class="separator:ab5a0f5954facad165ab605bde004ca19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1414fba75c47e40589b7f816c94998c9" id="r_a1414fba75c47e40589b7f816c94998c9"><td class="memItemLeft" align="right" valign="top"><a id="a1414fba75c47e40589b7f816c94998c9" name="a1414fba75c47e40589b7f816c94998c9"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>increase_memory_use</b> (std::size_t delta) noexcept</td></tr>
<tr class="memdesc:a1414fba75c47e40589b7f816c94998c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase tracked memory usage by <em>delta</em> bytes. <br /></td></tr>
<tr class="separator:a1414fba75c47e40589b7f816c94998c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa792d9faf1c0d8fc6f4fc57518cec179" id="r_aa792d9faf1c0d8fc6f4fc57518cec179"><td class="memItemLeft" align="right" valign="top"><a id="aa792d9faf1c0d8fc6f4fc57518cec179" name="aa792d9faf1c0d8fc6f4fc57518cec179"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>decrease_memory_use</b> (std::size_t delta) noexcept</td></tr>
<tr class="memdesc:aa792d9faf1c0d8fc6f4fc57518cec179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease tracked memory usage by <em>delta</em> bytes. <br /></td></tr>
<tr class="separator:aa792d9faf1c0d8fc6f4fc57518cec179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f7e0910b72f81a25fa64ab11304c21" id="r_ae6f7e0910b72f81a25fa64ab11304c21"><td class="memItemLeft" align="right" valign="top"><a id="ae6f7e0910b72f81a25fa64ab11304c21" name="ae6f7e0910b72f81a25fa64ab11304c21"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>increment_leaf_count</b> (std::size_t leaf_size) noexcept</td></tr>
<tr class="memdesc:ae6f7e0910b72f81a25fa64ab11304c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment leaf node count and bump memory usage by <em>leaf_size</em> bytes. <br /></td></tr>
<tr class="separator:ae6f7e0910b72f81a25fa64ab11304c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a133ddf566d20763e8c48a6e2a7224" id="r_a68a133ddf566d20763e8c48a6e2a7224"><td class="memItemLeft" align="right" valign="top"><a id="a68a133ddf566d20763e8c48a6e2a7224" name="a68a133ddf566d20763e8c48a6e2a7224"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>decrement_leaf_count</b> (std::size_t leaf_size) noexcept</td></tr>
<tr class="memdesc:a68a133ddf566d20763e8c48a6e2a7224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement leaf node count and decrease memory usage by <em>leaf_size</em> bytes. <br /></td></tr>
<tr class="separator:a68a133ddf566d20763e8c48a6e2a7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfafe8422cf924e24cba705c14938eda" id="r_acfafe8422cf924e24cba705c14938eda"><td class="memTemplParams" colspan="2">template&lt;class INode &gt; </td></tr>
<tr class="memitem:acfafe8422cf924e24cba705c14938eda"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#acfafe8422cf924e24cba705c14938eda">increment_inode_count</a> () noexcept</td></tr>
<tr class="memdesc:acfafe8422cf924e24cba705c14938eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment internal node count for given type.  <br /></td></tr>
<tr class="separator:acfafe8422cf924e24cba705c14938eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9d395471f31685f82211c361414582" id="r_a8c9d395471f31685f82211c361414582"><td class="memTemplParams" colspan="2">template&lt;class INode &gt; </td></tr>
<tr class="memitem:a8c9d395471f31685f82211c361414582"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a8c9d395471f31685f82211c361414582">decrement_inode_count</a> () noexcept</td></tr>
<tr class="memdesc:a8c9d395471f31685f82211c361414582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement internal node count for given type.  <br /></td></tr>
<tr class="separator:a8c9d395471f31685f82211c361414582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce47da2a6c03d1701efe68a2ff369a0" id="r_a9ce47da2a6c03d1701efe68a2ff369a0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </td></tr>
<tr class="memitem:a9ce47da2a6c03d1701efe68a2ff369a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a9ce47da2a6c03d1701efe68a2ff369a0">account_growing_inode</a> () noexcept</td></tr>
<tr class="memdesc:a9ce47da2a6c03d1701efe68a2ff369a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record node growth operation.  <br /></td></tr>
<tr class="separator:a9ce47da2a6c03d1701efe68a2ff369a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adef12733351be7fb469bb3282fa6f7" id="r_a0adef12733351be7fb469bb3282fa6f7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </td></tr>
<tr class="memitem:a0adef12733351be7fb469bb3282fa6f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classunodb_1_1db.html#a0adef12733351be7fb469bb3282fa6f7">account_shrinking_inode</a> () noexcept</td></tr>
<tr class="memdesc:a0adef12733351be7fb469bb3282fa6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record node shrink operation.  <br /></td></tr>
<tr class="separator:a0adef12733351be7fb469bb3282fa6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6bdfeeabb38a69ad6442ff7cd7ee6f15" id="r_a6bdfeeabb38a69ad6442ff7cd7ee6f15"><td class="memItemLeft" align="right" valign="top"><a id="a6bdfeeabb38a69ad6442ff7cd7ee6f15" name="a6bdfeeabb38a69ad6442ff7cd7ee6f15"></a>
<a class="el" href="namespaceunodb_1_1detail.html#aaa98550b35b9c4011a17dd6d7f96f25a">detail::node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> {nullptr}</td></tr>
<tr class="memdesc:a6bdfeeabb38a69ad6442ff7cd7ee6f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of the tree (nullptr if empty). <br /></td></tr>
<tr class="separator:a6bdfeeabb38a69ad6442ff7cd7ee6f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5d69b544ebdb7201f95ce4182f8756" id="r_a8d5d69b544ebdb7201f95ce4182f8756"><td class="memItemLeft" align="right" valign="top"><a id="a8d5d69b544ebdb7201f95ce4182f8756" name="a8d5d69b544ebdb7201f95ce4182f8756"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>current_memory_use</b> {0}</td></tr>
<tr class="memdesc:a8d5d69b544ebdb7201f95ce4182f8756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current memory use by all tree nodes in bytes. <br /></td></tr>
<tr class="separator:a8d5d69b544ebdb7201f95ce4182f8756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e63a8c86777d87993e01f70b8c78e1" id="r_ae7e63a8c86777d87993e01f70b8c78e1"><td class="memItemLeft" align="right" valign="top"><a id="ae7e63a8c86777d87993e01f70b8c78e1" name="ae7e63a8c86777d87993e01f70b8c78e1"></a>
<a class="el" href="namespaceunodb.html#a8105523dd9adff845377f54dd034b838">node_type_counter_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>node_counts</b> {}</td></tr>
<tr class="memdesc:ae7e63a8c86777d87993e01f70b8c78e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of nodes by type. <br /></td></tr>
<tr class="separator:ae7e63a8c86777d87993e01f70b8c78e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a7b68f7653bb056991c3484aac452c" id="r_a41a7b68f7653bb056991c3484aac452c"><td class="memItemLeft" align="right" valign="top"><a id="a41a7b68f7653bb056991c3484aac452c" name="a41a7b68f7653bb056991c3484aac452c"></a>
<a class="el" href="namespaceunodb.html#a60a52550ffa9f2d0d9e1cd9ebc7cab28">inode_type_counter_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>growing_inode_counts</b> {}</td></tr>
<tr class="memdesc:a41a7b68f7653bb056991c3484aac452c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of node growth operations by internal node type. <br /></td></tr>
<tr class="separator:a41a7b68f7653bb056991c3484aac452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814bf5c1215b6a976c172351cf60070f" id="r_a814bf5c1215b6a976c172351cf60070f"><td class="memItemLeft" align="right" valign="top"><a id="a814bf5c1215b6a976c172351cf60070f" name="a814bf5c1215b6a976c172351cf60070f"></a>
<a class="el" href="namespaceunodb.html#a60a52550ffa9f2d0d9e1cd9ebc7cab28">inode_type_counter_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>shrinking_inode_counts</b> {}</td></tr>
<tr class="memdesc:a814bf5c1215b6a976c172351cf60070f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of node shrink operations by internal node type. <br /></td></tr>
<tr class="separator:a814bf5c1215b6a976c172351cf60070f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5b2c73086774ade59730e34d097da2" id="r_a3c5b2c73086774ade59730e34d097da2"><td class="memItemLeft" align="right" valign="top"><a id="a3c5b2c73086774ade59730e34d097da2" name="a3c5b2c73086774ade59730e34d097da2"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>key_prefix_splits</b> {0}</td></tr>
<tr class="memdesc:a3c5b2c73086774ade59730e34d097da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of key prefix split operations. <br /></td></tr>
<tr class="separator:a3c5b2c73086774ade59730e34d097da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac95537d22e30cfb9415ea8b86b94cacc" id="r_ac95537d22e30cfb9415ea8b86b94cacc"><td class="memItemLeft" align="right" valign="top"><a id="ac95537d22e30cfb9415ea8b86b94cacc" name="ac95537d22e30cfb9415ea8b86b94cacc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>mutex_db&lt; Key, Value &gt;</b></td></tr>
<tr class="memdesc:ac95537d22e30cfb9415ea8b86b94cacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow <a class="el" href="classunodb_1_1mutex__db.html" title="A thread-safe implementation of the Adaptive Radix Tree (ART) using an explicit global lock.">mutex_db</a> to access private members for thread-safe wrapper. <br /></td></tr>
<tr class="separator:ac95537d22e30cfb9415ea8b86b94cacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae619cc4a8d95fc5ddc04afd1eb7f2417" id="r_ae619cc4a8d95fc5ddc04afd1eb7f2417"><td class="memTemplParams" colspan="2"><a id="ae619cc4a8d95fc5ddc04afd1eb7f2417" name="ae619cc4a8d95fc5ddc04afd1eb7f2417"></a>
template&lt;class &gt; </td></tr>
<tr class="memitem:ae619cc4a8d95fc5ddc04afd1eb7f2417"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detail::basic_db_leaf_deleter</b></td></tr>
<tr class="memdesc:ae619cc4a8d95fc5ddc04afd1eb7f2417"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunodb_1_1detail_1_1basic__db__leaf__deleter.html" title="Functor to delete leaf nodes through database.">detail::basic_db_leaf_deleter</a> <br /></td></tr>
<tr class="separator:ae619cc4a8d95fc5ddc04afd1eb7f2417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c802fc92dd464a0e3c4e8acbb4111" id="r_a751c802fc92dd464a0e3c4e8acbb4111"><td class="memTemplParams" colspan="2"><a id="a751c802fc92dd464a0e3c4e8acbb4111" name="a751c802fc92dd464a0e3c4e8acbb4111"></a>
template&lt;typename , typename , template&lt; typename, typename &gt; class, template&lt; class &gt; class, class , class , class , template&lt; typename, typename &gt; class, template&lt; typename, typename, class &gt; class, template&lt; class &gt; class&gt; </td></tr>
<tr class="memitem:a751c802fc92dd464a0e3c4e8acbb4111"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detail::basic_art_policy</b></td></tr>
<tr class="memdesc:a751c802fc92dd464a0e3c4e8acbb4111"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structunodb_1_1detail_1_1basic__art__policy.html" title="Policy class encapsulating ART implementation differences.">detail::basic_art_policy</a> <br /></td></tr>
<tr class="separator:a751c802fc92dd464a0e3c4e8acbb4111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96ae9741ef57bdec0060d3b43f2fd36" id="r_ae96ae9741ef57bdec0060d3b43f2fd36"><td class="memTemplParams" colspan="2"><a id="ae96ae9741ef57bdec0060d3b43f2fd36" name="ae96ae9741ef57bdec0060d3b43f2fd36"></a>
template&lt;typename , class &gt; </td></tr>
<tr class="memitem:ae96ae9741ef57bdec0060d3b43f2fd36"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detail::basic_db_inode_deleter</b></td></tr>
<tr class="memdesc:ae96ae9741ef57bdec0060d3b43f2fd36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunodb_1_1detail_1_1basic__db__inode__deleter.html" title="Functor to delete internal nodes through database.">detail::basic_db_inode_deleter</a> <br /></td></tr>
<tr class="separator:ae96ae9741ef57bdec0060d3b43f2fd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac00839cde174b4727ab403c590b3670" id="r_aac00839cde174b4727ab403c590b3670"><td class="memItemLeft" align="right" valign="top"><a id="aac00839cde174b4727ab403c590b3670" name="aac00839cde174b4727ab403c590b3670"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>detail::impl_helpers</b></td></tr>
<tr class="memdesc:aac00839cde174b4727ab403c590b3670"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structunodb_1_1detail_1_1impl__helpers.html" title="Helper functions for node insertion and removal operations.">detail::impl_helpers</a> <br /></td></tr>
<tr class="separator:aac00839cde174b4727ab403c590b3670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89c17ec8f9927cb10e6da9f64a20f00" id="r_ad89c17ec8f9927cb10e6da9f64a20f00"><td class="memItemLeft" align="right" valign="top"><a id="ad89c17ec8f9927cb10e6da9f64a20f00" name="ad89c17ec8f9927cb10e6da9f64a20f00"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>detail::make_db_leaf_ptr</b> (<a class="el" href="classunodb_1_1db.html#aa6414555472551bb85db668441cccfae">art_key_type</a>, <a class="el" href="classunodb_1_1db.html#a9217d27d320c8d140a52bfd05031248e">value_view</a>, <a class="el" href="classunodb_1_1db.html">db</a> &amp;)</td></tr>
<tr class="memdesc:ad89c17ec8f9927cb10e6da9f64a20f00"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceunodb_1_1detail.html#a4c36ae56cc3f27abfb2624d79ff4be78" title="Create unique pointer to new leaf with given key and value.">detail::make_db_leaf_ptr</a> <br /></td></tr>
<tr class="separator:ad89c17ec8f9927cb10e6da9f64a20f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Value&gt;<br />
class unodb::db&lt; Key, Value &gt;</div><p>A non-thread-safe implementation of the Adaptive Radix Tree (ART). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classunodb_1_1olc__db.html" title="A thread-safe Adaptive Radix Tree that is synchronized using optimistic lock coupling.">unodb::olc_db</a> for a highly concurrent thread-safe ART implementation. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8040aaa218a91aa2c6e8cb3f5fc86f09" name="a8040aaa218a91aa2c6e8cb3f5fc86f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8040aaa218a91aa2c6e8cb3f5fc86f09">&#9670;&#160;</a></span>get_result</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_result =  std::optional&lt;<a class="el" href="classunodb_1_1db.html#a9217d27d320c8d140a52bfd05031248e">value_view</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result type for get operations. </p>
<p>Contains value_view if key was found, otherwise empty. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ce47da2a6c03d1701efe68a2ff369a0" name="a9ce47da2a6c03d1701efe68a2ff369a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce47da2a6c03d1701efe68a2ff369a0">&#9670;&#160;</a></span>account_growing_inode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::account_growing_inode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record node growth operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeType</td><td>Node type that was grown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0adef12733351be7fb469bb3282fa6f7" name="a0adef12733351be7fb469bb3282fa6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adef12733351be7fb469bb3282fa6f7">&#9670;&#160;</a></span>account_shrinking_inode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::account_shrinking_inode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record node shrink operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeType</td><td>Node type that was shrunk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a35859ae49a6255bfa729ebe12702fd" name="a6a35859ae49a6255bfa729ebe12702fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a35859ae49a6255bfa729ebe12702fd">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all entries in the index. </p>
<p>After this operation, <a class="el" href="classunodb_1_1db.html#a889caf36fba0297367a3061d7b580901" title="Return true iff the index is empty.">empty()</a> returns true and all memory used by tree nodes is freed. Node growth/shrink counters are preserved. </p>

</div>
</div>
<a id="a8c9d395471f31685f82211c361414582" name="a8c9d395471f31685f82211c361414582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9d395471f31685f82211c361414582">&#9670;&#160;</a></span>decrement_inode_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;class INode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::decrement_inode_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement internal node count for given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INode</td><td>Internal node class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5847a8985a8d87ae07d2a8667a16239d" name="a5847a8985a8d87ae07d2a8667a16239d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5847a8985a8d87ae07d2a8667a16239d">&#9670;&#160;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output tree structure to stderr for debugging. </p>
<p>Convenience wrapper for <code>dump(std::cerr)</code>. </p><dl class="section note"><dt>Note</dt><dd>For debugging purposes only, not part of stable API </dd></dl>

</div>
</div>
<a id="ace60a7cffca8eaed4b623eaaf7ba78b7" name="ace60a7cffca8eaed4b623eaaf7ba78b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace60a7cffca8eaed4b623eaaf7ba78b7">&#9670;&#160;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output tree structure to stream for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream to write tree representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For debugging purposes only, not part of stable API </dd></dl>

</div>
</div>
<a id="a7a9e7a9acc9be89745bba099062f7bc4" name="a7a9e7a9acc9be89745bba099062f7bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9e7a9acc9be89745bba099062f7bc4">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunodb_1_1db.html#a8040aaa218a91aa2c6e8cb3f5fc86f09">get_result</a> <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>search_key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query for a value associated with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_key</td><td>If Key is a simple primitive type, then it is converted into a binary comparable key. If Key is <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90" title="Non-owning view of key bytes, copied into index upon insertion.">unodb::key_view</a>, then it is assumed to already be a binary comparable key, e.g., as produced by <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0705aacac581408a26b3b6741687c9d" name="ac0705aacac581408a26b3b6741687c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0705aacac581408a26b3b6741687c9d">&#9670;&#160;</a></span>get_current_memory_use()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_current_memory_use </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return current memory use by tree nodes in bytes. </p>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="aa33bdb6e96d491512f1656f176f2bb59" name="aa33bdb6e96d491512f1656f176f2bb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33bdb6e96d491512f1656f176f2bb59">&#9670;&#160;</a></span>get_growing_inode_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_growing_inode_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return count of growing operations for given inode type. </p>
<p>Growing operations occur when an internal node reaches capacity and is replaced with a larger node type (e.g., <a class="el" href="classunodb_1_1detail_1_1inode__4.html" title="Internal node with 4 children for non-thread-safe ART.">detail::inode_4</a> to <a class="el" href="classunodb_1_1detail_1_1inode__16.html" title="Internal node with 16 children for non-thread-safe ART.">detail::inode_16</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeType</td><td>Internal node type (<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a3542ac61a301c83960ca9c44a79260e9" title="Internal node for 2-4 children.">node_type::I4</a>, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3abcd774f891b5f9df7099f3ea75dadf8d" title="Internal node for 5-16 children.">node_type::I16</a>, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a62e917add11d7e69f1356f76800cd084" title="Internal node for 17-48 children.">node_type::I48</a>, or <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a4db1a4fc0ba7faa34813bde8556fccda" title="Internal node for 49-256 children.">node_type::I256</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of growth operations that created a node of this type </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="a826e03c799300f945a0e663a801185b1" name="a826e03c799300f945a0e663a801185b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826e03c799300f945a0e663a801185b1">&#9670;&#160;</a></span>get_growing_inode_counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceunodb.html#a60a52550ffa9f2d0d9e1cd9ebc7cab28">inode_type_counter_array</a> <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_growing_inode_counts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return counts of all growing inode operations. </p>
<dl class="section return"><dt>Returns</dt><dd>Array indexed by internal node type containing growth counts </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="a60bcec7d62e67207135e908b1fd607fc" name="a60bcec7d62e67207135e908b1fd607fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bcec7d62e67207135e908b1fd607fc">&#9670;&#160;</a></span>get_key_prefix_splits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_key_prefix_splits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return count of key prefix split operations. </p>
<p>Key prefix splits occur when inserting a key that differs from an existing node's key prefix, requiring the node to be split into a new internal node with two children.</p>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="ad212d72357366800d501bb601f2cadd8" name="ad212d72357366800d501bb601f2cadd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad212d72357366800d501bb601f2cadd8">&#9670;&#160;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_node_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return count of nodes of given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeType</td><td>Node type to count (<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a5c19bc679506425e481a34caff777350" title="Leaf node for a single value.">node_type::LEAF</a>, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a3542ac61a301c83960ca9c44a79260e9" title="Internal node for 2-4 children.">node_type::I4</a>, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3abcd774f891b5f9df7099f3ea75dadf8d" title="Internal node for 5-16 children.">node_type::I16</a>, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a62e917add11d7e69f1356f76800cd084" title="Internal node for 17-48 children.">node_type::I48</a>, or <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a4db1a4fc0ba7faa34813bde8556fccda" title="Internal node for 49-256 children.">node_type::I256</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="a58e8f31d59d74ca76710b56ee5953677" name="a58e8f31d59d74ca76710b56ee5953677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e8f31d59d74ca76710b56ee5953677">&#9670;&#160;</a></span>get_node_counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceunodb.html#a8105523dd9adff845377f54dd034b838">node_type_counter_array</a> <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_node_counts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return counts of all node types. </p>
<dl class="section return"><dt>Returns</dt><dd>Array indexed by node_type containing counts </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="a257561ecf32c807080442bfbee2d8429" name="a257561ecf32c807080442bfbee2d8429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257561ecf32c807080442bfbee2d8429">&#9670;&#160;</a></span>get_shrinking_inode_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3">node_type</a> NodeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint64_t <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_shrinking_inode_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return count of shrinking operations for given inode type. </p>
<p>Shrinking operations occur when an internal node falls below minimum occupancy and is replaced with a smaller node type (e.g., <a class="el" href="classunodb_1_1detail_1_1inode__16.html" title="Internal node with 16 children for non-thread-safe ART.">detail::inode_16</a> to <a class="el" href="classunodb_1_1detail_1_1inode__4.html" title="Internal node with 4 children for non-thread-safe ART.">detail::inode_4</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeType</td><td>Internal node type (<a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a3542ac61a301c83960ca9c44a79260e9" title="Internal node for 2-4 children.">node_type::I4</a>, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3abcd774f891b5f9df7099f3ea75dadf8d" title="Internal node for 5-16 children.">node_type::I16</a>, <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a62e917add11d7e69f1356f76800cd084" title="Internal node for 17-48 children.">node_type::I48</a>, or <a class="el" href="namespaceunodb.html#a074fabb6a852ee032fb9b7f35a64b8e3a4db1a4fc0ba7faa34813bde8556fccda" title="Internal node for 49-256 children.">node_type::I256</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of times this node type was shrunk to a smaller type </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="af83c0f84e7ed86b932aed9322cb47b7f" name="af83c0f84e7ed86b932aed9322cb47b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83c0f84e7ed86b932aed9322cb47b7f">&#9670;&#160;</a></span>get_shrinking_inode_counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceunodb.html#a60a52550ffa9f2d0d9e1cd9ebc7cab28">inode_type_counter_array</a> <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::get_shrinking_inode_counts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return counts of all shrinking inode operations. </p>
<dl class="section return"><dt>Returns</dt><dd>Array indexed by internal node type containing shrink counts </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available when compiled with UNODB_DETAIL_WITH_STATS defined. </dd></dl>

</div>
</div>
<a id="acfafe8422cf924e24cba705c14938eda" name="acfafe8422cf924e24cba705c14938eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfafe8422cf924e24cba705c14938eda">&#9670;&#160;</a></span>increment_inode_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;class INode &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::increment_inode_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment internal node count for given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INode</td><td>Internal node class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7358904a10483d1e9857b81e0aa38152" name="a7358904a10483d1e9857b81e0aa38152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7358904a10483d1e9857b81e0aa38152">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>insert_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunodb_1_1db.html#aadaa147eb4dc87207e42fb481ce46678">value_type</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value under a key iff there is no entry for that key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_key</td><td>If Key is a simple primitive type, then it is converted into a binary comparable key. If Key is <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90" title="Non-owning view of key bytes, copied into index upon insertion.">unodb::key_view</a>, then it is assumed to already be a binary comparable key, e.g., as produced by <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a>.</td></tr>
    <tr><td class="paramname">v</td><td>The value of type <code>value_type</code> to be inserted under that key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the key value pair was inserted.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cannot be called during stack unwinding with <code>std::uncaught_exceptions() &gt; 0</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">key_encoder</a>, which provides for encoding text and multi-field records when Key is <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90" title="Non-owning view of key bytes, copied into index upon insertion.">unodb::key_view</a>. </dd></dl>

</div>
</div>
<a id="af1862efafda8cc7a6e422796af77b416" name="af1862efafda8cc7a6e422796af77b416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1862efafda8cc7a6e422796af77b416">&#9670;&#160;</a></span>insert_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::insert_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunodb_1_1db.html#aa6414555472551bb85db668441cccfae">art_key_type</a>&#160;</td>
          <td class="paramname"><em>insert_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunodb_1_1db.html#aadaa147eb4dc87207e42fb481ce46678">value_type</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value under an encoded key iff there is no entry for that key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insert_key</td><td>Encoded key to insert </td></tr>
    <tr><td class="paramname">v</td><td>Value to associate with the key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cannot be called during stack unwinding with <code>std::uncaught_exceptions() &gt; 0</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the key value pair was inserted. </dd></dl>

</div>
</div>
<a id="ad9ca6b1eea4f0b912097978dd1eba982" name="ad9ca6b1eea4f0b912097978dd1eba982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ca6b1eea4f0b912097978dd1eba982">&#9670;&#160;</a></span>key_found()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::key_found </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classunodb_1_1db.html#a8040aaa218a91aa2c6e8cb3f5fc86f09">get_result</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if get operation found a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Result from <a class="el" href="classunodb_1_1db.html#a7a9e7a9acc9be89745bba099062f7bc4" title="Query for a value associated with a key.">get()</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key was found, false otherwise </dd></dl>

</div>
</div>
<a id="acdd57c327e541afc96495bb543390cff" name="acdd57c327e541afc96495bb543390cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd57c327e541afc96495bb543390cff">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>search_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the entry associated with the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_key</td><td>If Key is a simple primitive type, then it is converted into a binary comparable key. If Key is <a class="el" href="namespaceunodb.html#a37e43379ef5bf4922acff8db9a432a90" title="Non-owning view of key bytes, copied into index upon insertion.">unodb::key_view</a>, then it is assumed to already be a binary comparable key, e.g., as produced by <a class="el" href="classunodb_1_1key__encoder.html" title="A utility class to generate binary comparable keys from a sequence of key components.">unodb::key_encoder</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the delete was successful (i.e. the key was found in the tree and the associated index entry was removed). </dd></dl>

</div>
</div>
<a id="a2ad83dc7ab1473008d02fea28905ae87" name="a2ad83dc7ab1473008d02fea28905ae87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad83dc7ab1473008d02fea28905ae87">&#9670;&#160;</a></span>remove_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::remove_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunodb_1_1db.html#aa6414555472551bb85db668441cccfae">art_key_type</a>&#160;</td>
          <td class="paramname"><em>remove_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the entry associated with the encoded key <em>remove_key</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the delete was successful (i.e. the key was found in the tree and the associated index entry was removed). </dd></dl>

</div>
</div>
<a id="a27a69c736ca0405bc8eaed20cf875a09" name="a27a69c736ca0405bc8eaed20cf875a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a69c736ca0405bc8eaed20cf875a09">&#9670;&#160;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;typename FN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::scan </td>
          <td>(</td>
          <td class="paramtype">FN&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan the tree, applying the caller's lambda to each visited leaf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>A function <code>f(<a class="el" href="classunodb_1_1visitor.html" title="Wrapper providing access to key and value during index scan.">unodb::visitor</a>&lt;<a class="el" href="classunodb_1_1db_1_1iterator.html" title="Internal iterator for tree traversal.">unodb::db::iterator</a>&gt;&amp;)</code> returning <code>bool</code>. The traversal will halt if the function returns <code>true</code>.</td></tr>
    <tr><td class="paramname">fwd</td><td>When <code>true</code> perform a forward scan, otherwise perform a reverse scan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d68530937371b08951f2084761b56fd" name="a5d68530937371b08951f2084761b56fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d68530937371b08951f2084761b56fd">&#9670;&#160;</a></span>scan_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;typename FN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::scan_from </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>from_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FN&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan in the indicated direction, applying the caller's lambda to each visited leaf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_key</td><td>is an inclusive lower bound for the starting point of the scan.</td></tr>
    <tr><td class="paramname">fn</td><td>A function <code>f(<a class="el" href="classunodb_1_1visitor.html" title="Wrapper providing access to key and value during index scan.">unodb::visitor</a>&lt;<a class="el" href="classunodb_1_1db_1_1iterator.html" title="Internal iterator for tree traversal.">unodb::db::iterator</a>&gt;&amp;)</code> returning <code>bool</code>. The traversal will halt if the function returns <code>true</code>.</td></tr>
    <tr><td class="paramname">fwd</td><td>When <code>true</code> perform a forward scan, otherwise perform a reverse scan. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f45c60b21a68bfd64062ca2c2be2ddf" name="a5f45c60b21a68bfd64062ca2c2be2ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f45c60b21a68bfd64062ca2c2be2ddf">&#9670;&#160;</a></span>scan_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
<div class="memtemplate">
template&lt;typename FN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classunodb_1_1db.html">unodb::db</a>&lt; Key, Value &gt;::scan_range </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>from_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>to_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FN&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan a half-open key range, applying the caller's lambda to each visited leaf. </p>
<p>The scan will proceed in lexicographic order iff <em>from_key</em> is less than <em>to_key</em> and in reverse lexicographic order iff <em>to_key</em> is less than <em>from_key</em>. When <code>from_key &lt; to_key</code>, the scan will visit all index entries in the half-open range <code>[from_key,to_key)</code> in forward order. Otherwise the scan will visit all index entries in the half-open range <code>(from_key,to_key]</code> in reverse order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_key</td><td>is an inclusive bound for the starting point of the scan.</td></tr>
    <tr><td class="paramname">to_key</td><td>is an exclusive bound for the ending point of the scan.</td></tr>
    <tr><td class="paramname">fn</td><td>A function <code>f(<a class="el" href="classunodb_1_1visitor.html" title="Wrapper providing access to key and value during index scan.">unodb::visitor</a>&lt;<a class="el" href="classunodb_1_1db_1_1iterator.html" title="Internal iterator for tree traversal.">unodb::db::iterator</a>&gt;&amp;)</code> returning <code>bool</code>. The traversal will halt if the function returns <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="art_8hpp_source.html">art.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceunodb.html">unodb</a></li><li class="navelem"><a class="el" href="classunodb_1_1db.html">db</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
